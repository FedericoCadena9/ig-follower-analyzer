<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Instagram Follower Analyzer</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-50 min-h-screen">
  <div id="app"></div>

<script>
const { createApp, ref, computed, reactive } = Vue;

// DropZone Component
const DropZone = {
  props: {
    label: String,
    accept: { type: String, default: '.json' },
    loaded: Boolean,
    count: { type: Number, default: null },
    error: { type: String, default: null }
  },
  emits: ['file-loaded'],
  setup(props, { emit }) {
    const isDragging = ref(false);
    const fileInput = ref(null);

    const handleDrop = (e) => {
      isDragging.value = false;
      const file = e.dataTransfer.files[0];
      if (file) processFile(file);
    };

    const handleClick = () => {
      fileInput.value?.click();
    };

    const handleFileSelect = (e) => {
      const file = e.target.files[0];
      if (file) processFile(file);
    };

    const processFile = (file) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          emit('file-loaded', { data, filename: file.name });
        } catch (err) {
          emit('file-loaded', { error: 'JSON inv√°lido: ' + err.message });
        }
      };
      reader.readAsText(file);
    };

    return { isDragging, fileInput, handleDrop, handleClick, handleFileSelect };
  },
  template: `
    <div
      @click="handleClick"
      @dragover.prevent="isDragging = true"
      @dragleave.prevent="isDragging = false"
      @drop.prevent="handleDrop"
      class="relative border-2 border-dashed rounded-xl p-6 text-center cursor-pointer transition-all min-h-[120px] flex flex-col items-center justify-center"
      :class="{
        'border-blue-400 bg-blue-50': isDragging,
        'border-green-400 bg-green-50': loaded && !error,
        'border-red-400 bg-red-50': error,
        'border-gray-300 bg-white hover:border-gray-400 hover:bg-gray-50': !isDragging && !loaded && !error
      }"
    >
      <input
        ref="fileInput"
        type="file"
        :accept="accept"
        @change="handleFileSelect"
        class="hidden"
      />

      <div v-if="error" class="text-red-600">
        <span class="text-2xl">‚ùå</span>
        <p class="mt-2 font-medium">Error</p>
        <p class="text-sm">{{ error }}</p>
      </div>

      <div v-else-if="loaded" class="text-green-600">
        <span class="text-2xl">‚úÖ</span>
        <p class="mt-2 font-medium">{{ label }}</p>
        <p class="text-sm text-green-700" v-if="count !== null">{{ count.toLocaleString() }} registros</p>
      </div>

      <div v-else class="text-gray-500">
        <span class="text-2xl">üìÅ</span>
        <p class="mt-2 font-medium">{{ label }}</p>
        <p class="text-sm">Arrastra o haz clic</p>
      </div>
    </div>
  `
};

// Normalizer utility
const normalizeData = (data, type) => {
  const warnings = [];
  const normalized = new Map();

  // Detect format and extract array
  let items;
  if (Array.isArray(data)) {
    items = data;
  } else if (data.relationships_following) {
    items = data.relationships_following;
  } else if (data.relationships_followers) {
    items = data.relationships_followers;
  } else {
    const arrayProp = Object.keys(data).find(k => Array.isArray(data[k]));
    if (arrayProp) {
      items = data[arrayProp];
      warnings.push({
        type: 'info',
        message: `Formato detectado: usando propiedad "${arrayProp}"`
      });
    } else {
      return { normalized, warnings: [{ type: 'error', message: 'No se encontr√≥ array de usuarios en el archivo' }] };
    }
  }

  if (!items || items.length === 0) {
    return { normalized, warnings: [{ type: 'error', message: 'El archivo no contiene usuarios' }] };
  }

  const sixMonthsAgo = Math.floor(Date.now() / 1000) - 15768000;
  let mostRecentTimestamp = 0;
  const seenHrefs = new Map();

  for (const item of items) {
    const stringData = item.string_list_data?.[0];
    if (!stringData) {
      warnings.push({
        type: 'warning',
        message: `Usuario "${item.title || 'desconocido'}" no tiene datos v√°lidos`
      });
      continue;
    }

    const { href, value, timestamp } = stringData;

    if (timestamp > mostRecentTimestamp) {
      mostRecentTimestamp = timestamp;
    }

    if (seenHrefs.has(href)) {
      const existing = seenHrefs.get(href);
      warnings.push({
        type: 'warning',
        message: `Duplicado: "${value}" aparece m√°s de una vez`
      });
      if (timestamp > existing.timestamp) {
        seenHrefs.set(href, { username: value, href, timestamp });
      }
      continue;
    }

    if (!href?.includes('instagram.com/')) {
      warnings.push({
        type: 'warning',
        message: `URL inv√°lida para "${value}": ${href}`
      });
    }

    seenHrefs.set(href, { username: value, href, timestamp });
  }

  if (mostRecentTimestamp > 0 && mostRecentTimestamp < sixMonthsAgo) {
    const date = new Date(mostRecentTimestamp * 1000).toLocaleDateString('es');
    warnings.push({
      type: 'info',
      message: `Datos desactualizados: √∫ltimo registro del ${date}. Considera descargar datos frescos.`
    });
  }

  for (const [href, user] of seenHrefs) {
    normalized.set(href, user);
  }

  return { normalized, warnings };
};

// Compare followers and following
const compareUsers = (followersMap, followingMap, whitelistSet) => {
  const notFollowingBack = [];
  const warnings = [];

  for (const [href, user] of followingMap) {
    if (whitelistSet.has(user.username.toLowerCase())) {
      continue;
    }

    if (!followersMap.has(href)) {
      notFollowingBack.push(user);
    } else {
      const follower = followersMap.get(href);
      if (follower.username !== user.username) {
        warnings.push({
          type: 'warning',
          message: `Username cambiado: "${follower.username}" ‚Üí "${user.username}" (mismo perfil)`
        });
      }
    }
  }

  notFollowingBack.sort((a, b) => b.timestamp - a.timestamp);
  return { notFollowingBack, warnings };
};

// Parse whitelist (supports array or object format)
const parseWhitelist = (data) => {
  if (Array.isArray(data)) {
    return new Set(data.map(u => u.toLowerCase()));
  }
  if (data?.usernames && Array.isArray(data.usernames)) {
    return new Set(data.usernames.map(u => u.toLowerCase()));
  }
  return new Set();
};

createApp({
  components: { DropZone },
  setup() {
    const followers = ref(null);
    const following = ref(null);
    const whitelist = ref(null);
    const errors = reactive({
      followers: null,
      following: null,
      whitelist: null
    });

    const followersNormalized = ref(null);
    const followingNormalized = ref(null);
    const whitelistSet = ref(new Set());
    const allWarnings = ref([]);
    const results = ref([]);

    const storedWhitelist = localStorage.getItem('ig-analyzer-whitelist');
    if (storedWhitelist) {
      try {
        const parsed = JSON.parse(storedWhitelist);
        whitelistSet.value = new Set(parsed.usernames?.map(u => u.toLowerCase()) || []);
      } catch (e) {
        console.warn('Could not parse stored whitelist');
      }
    }

    const saveWhitelist = () => {
      const data = {
        version: 1,
        updatedAt: new Date().toISOString(),
        usernames: Array.from(whitelistSet.value)
      };
      localStorage.setItem('ig-analyzer-whitelist', JSON.stringify(data));
    };

    const processData = () => {
      if (!followers.value || !following.value) return;

      const warnings = [];

      const { normalized: normFollowers, warnings: warnFollowers } = normalizeData(followers.value, 'followers');
      followersNormalized.value = normFollowers;
      warnings.push(...warnFollowers);

      const { normalized: normFollowing, warnings: warnFollowing } = normalizeData(following.value, 'following');
      followingNormalized.value = normFollowing;
      warnings.push(...warnFollowing);

      const hasBlockingError = warnings.some(w => w.type === 'error');
      if (hasBlockingError) {
        allWarnings.value = warnings;
        results.value = [];
        return;
      }

      if (whitelist.value) {
        const imported = parseWhitelist(whitelist.value);
        for (const username of imported) {
          whitelistSet.value.add(username);
        }
        saveWhitelist();
      }

      const { notFollowingBack, warnings: compareWarnings } = compareUsers(
        normFollowers,
        normFollowing,
        whitelistSet.value
      );

      warnings.push(...compareWarnings);
      allWarnings.value = warnings;
      results.value = notFollowingBack;
    };

    const handleFollowersLoaded = ({ data, error }) => {
      if (error) {
        errors.followers = error;
        followers.value = null;
      } else {
        errors.followers = null;
        followers.value = data;
        processData();
      }
    };

    const handleFollowingLoaded = ({ data, error }) => {
      if (error) {
        errors.following = error;
        following.value = null;
      } else {
        errors.following = null;
        following.value = data;
        processData();
      }
    };

    const handleWhitelistLoaded = ({ data, error }) => {
      if (error) {
        errors.whitelist = error;
        whitelist.value = null;
      } else {
        errors.whitelist = null;
        whitelist.value = data;
        processData();
      }
    };

    const followersCount = computed(() => {
      if (!followers.value) return null;
      return Array.isArray(followers.value) ? followers.value.length : 0;
    });

    const followingCount = computed(() => {
      if (!following.value) return null;
      const data = following.value.relationships_following || following.value;
      return Array.isArray(data) ? data.length : 0;
    });

    return {
      followers,
      following,
      whitelist,
      errors,
      followersCount,
      followingCount,
      handleFollowersLoaded,
      handleFollowingLoaded,
      handleWhitelistLoaded,
      allWarnings,
      results,
      whitelistSet,
      processData,
      saveWhitelist
    };
  },
  template: `
    <div class="max-w-4xl mx-auto px-4 py-8">
      <header class="text-center mb-8">
        <h1 class="text-2xl md:text-3xl font-bold text-gray-800">üìä Instagram Follower Analyzer</h1>
        <p class="text-gray-600 mt-2">Descubre qui√©n no te sigue de vuelta</p>
      </header>

      <section class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
        <DropZone
          label="Followers"
          :loaded="!!followers"
          :count="followersCount"
          :error="errors.followers"
          @file-loaded="handleFollowersLoaded"
        />
        <DropZone
          label="Following"
          :loaded="!!following"
          :count="followingCount"
          :error="errors.following"
          @file-loaded="handleFollowingLoaded"
        />
        <DropZone
          label="Whitelist (opcional)"
          :loaded="!!whitelist"
          :count="Array.isArray(whitelist) ? whitelist.length : whitelist?.usernames?.length"
          :error="errors.whitelist"
          @file-loaded="handleWhitelistLoaded"
        />
      </section>

      <div v-if="followers && following" class="text-center text-gray-600">
        <p v-if="results.length > 0">{{ results.length }} cuentas no te siguen de vuelta</p>
        <p v-else>Todos te siguen de vuelta!</p>
      </div>
    </div>
  `
}).mount('#app');
</script>
</body>
</html>
