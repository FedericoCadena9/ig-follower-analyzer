<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Instagram Follower Analyzer</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-50 min-h-screen">
  <div id="app"></div>

<script>
const { createApp, ref, computed, reactive } = Vue;

// DropZone Component
const DropZone = {
  props: {
    label: String,
    accept: { type: String, default: '.json' },
    loaded: Boolean,
    count: { type: Number, default: null },
    error: { type: String, default: null }
  },
  emits: ['file-loaded'],
  setup(props, { emit }) {
    const isDragging = ref(false);
    const fileInput = ref(null);

    const handleDrop = (e) => {
      isDragging.value = false;
      const file = e.dataTransfer.files[0];
      if (file) processFile(file);
    };

    const handleClick = () => {
      fileInput.value?.click();
    };

    const handleFileSelect = (e) => {
      const file = e.target.files[0];
      if (file) processFile(file);
    };

    const processFile = (file) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          emit('file-loaded', { data, filename: file.name });
        } catch (err) {
          emit('file-loaded', { error: 'JSON inv√°lido: ' + err.message });
        }
      };
      reader.readAsText(file);
    };

    return { isDragging, fileInput, handleDrop, handleClick, handleFileSelect };
  },
  template: `
    <div
      @click="handleClick"
      @dragover.prevent="isDragging = true"
      @dragleave.prevent="isDragging = false"
      @drop.prevent="handleDrop"
      class="relative border-2 border-dashed rounded-xl p-6 text-center cursor-pointer transition-all min-h-[120px] flex flex-col items-center justify-center"
      :class="{
        'border-blue-400 bg-blue-50': isDragging,
        'border-green-400 bg-green-50': loaded && !error,
        'border-red-400 bg-red-50': error,
        'border-gray-300 bg-white hover:border-gray-400 hover:bg-gray-50': !isDragging && !loaded && !error
      }"
    >
      <input
        ref="fileInput"
        type="file"
        :accept="accept"
        @change="handleFileSelect"
        class="hidden"
      />

      <div v-if="error" class="text-red-600">
        <span class="text-2xl">‚ùå</span>
        <p class="mt-2 font-medium">Error</p>
        <p class="text-sm">{{ error }}</p>
      </div>

      <div v-else-if="loaded" class="text-green-600">
        <span class="text-2xl">‚úÖ</span>
        <p class="mt-2 font-medium">{{ label }}</p>
        <p class="text-sm text-green-700" v-if="count !== null">{{ count.toLocaleString() }} registros</p>
      </div>

      <div v-else class="text-gray-500">
        <span class="text-2xl">üìÅ</span>
        <p class="mt-2 font-medium">{{ label }}</p>
        <p class="text-sm">Arrastra o haz clic</p>
      </div>
    </div>
  `
};

// Normalizer utility
const normalizeData = (data, type) => {
  const warnings = [];
  const normalized = new Map();

  // Detect format and extract array
  let items;
  if (Array.isArray(data)) {
    items = data;
  } else if (data.relationships_following) {
    items = data.relationships_following;
  } else if (data.relationships_followers) {
    items = data.relationships_followers;
  } else {
    const arrayProp = Object.keys(data).find(k => Array.isArray(data[k]));
    if (arrayProp) {
      items = data[arrayProp];
      warnings.push({
        type: 'info',
        message: `Formato detectado: usando propiedad "${arrayProp}"`
      });
    } else {
      return { normalized, warnings: [{ type: 'error', message: 'No se encontr√≥ array de usuarios en el archivo' }] };
    }
  }

  if (!items || items.length === 0) {
    return { normalized, warnings: [{ type: 'error', message: 'El archivo no contiene usuarios' }] };
  }

  const sixMonthsAgo = Math.floor(Date.now() / 1000) - 15768000;
  let mostRecentTimestamp = 0;
  const seenHrefs = new Map();

  for (const item of items) {
    const stringData = item.string_list_data?.[0];
    if (!stringData) {
      warnings.push({
        type: 'warning',
        message: `Usuario "${item.title || 'desconocido'}" no tiene datos v√°lidos`
      });
      continue;
    }

    const { href, value, timestamp } = stringData;

    if (timestamp > mostRecentTimestamp) {
      mostRecentTimestamp = timestamp;
    }

    if (seenHrefs.has(href)) {
      const existing = seenHrefs.get(href);
      warnings.push({
        type: 'warning',
        message: `Duplicado: "${value}" aparece m√°s de una vez`
      });
      if (timestamp > existing.timestamp) {
        seenHrefs.set(href, { username: value, href, timestamp });
      }
      continue;
    }

    if (!href?.includes('instagram.com/')) {
      warnings.push({
        type: 'warning',
        message: `URL inv√°lida para "${value}": ${href}`
      });
    }

    seenHrefs.set(href, { username: value, href, timestamp });
  }

  if (mostRecentTimestamp > 0 && mostRecentTimestamp < sixMonthsAgo) {
    const date = new Date(mostRecentTimestamp * 1000).toLocaleDateString('es');
    warnings.push({
      type: 'info',
      message: `Datos desactualizados: √∫ltimo registro del ${date}. Considera descargar datos frescos.`
    });
  }

  for (const [href, user] of seenHrefs) {
    normalized.set(href, user);
  }

  return { normalized, warnings };
};

// Compare followers and following
const compareUsers = (followersMap, followingMap, whitelistSet) => {
  const notFollowingBack = [];
  const warnings = [];

  for (const [href, user] of followingMap) {
    if (whitelistSet.has(user.username.toLowerCase())) {
      continue;
    }

    if (!followersMap.has(href)) {
      notFollowingBack.push(user);
    } else {
      const follower = followersMap.get(href);
      if (follower.username !== user.username) {
        warnings.push({
          type: 'warning',
          message: `Username cambiado: "${follower.username}" ‚Üí "${user.username}" (mismo perfil)`
        });
      }
    }
  }

  notFollowingBack.sort((a, b) => b.timestamp - a.timestamp);
  return { notFollowingBack, warnings };
};

// Parse whitelist (supports array or object format)
const parseWhitelist = (data) => {
  if (Array.isArray(data)) {
    return new Set(data.map(u => u.toLowerCase()));
  }
  if (data?.usernames && Array.isArray(data.usernames)) {
    return new Set(data.usernames.map(u => u.toLowerCase()));
  }
  return new Set();
};

// WarningsPanel Component
const WarningsPanel = {
  props: {
    warnings: { type: Array, default: () => [] }
  },
  setup(props) {
    const isExpanded = ref(true);

    const groupedWarnings = computed(() => {
      const groups = { error: [], warning: [], info: [] };
      for (const w of props.warnings) {
        groups[w.type]?.push(w);
      }
      return groups;
    });

    const hasWarnings = computed(() => props.warnings.length > 0);

    return { isExpanded, groupedWarnings, hasWarnings };
  },
  template: `
    <div v-if="hasWarnings" class="mb-6">
      <button
        @click="isExpanded = !isExpanded"
        class="w-full flex items-center justify-between p-4 bg-amber-50 border border-amber-200 rounded-lg hover:bg-amber-100 transition-colors"
      >
        <span class="flex items-center gap-2 font-medium text-amber-800">
          <span>‚ö†Ô∏è</span>
          <span>{{ warnings.length }} problema{{ warnings.length !== 1 ? 's' : '' }} encontrado{{ warnings.length !== 1 ? 's' : '' }}</span>
        </span>
        <span class="text-amber-600">{{ isExpanded ? '‚ñº' : '‚ñ∂' }}</span>
      </button>

      <div v-show="isExpanded" class="mt-3 space-y-3">
        <!-- Errors -->
        <div
          v-for="(warning, idx) in groupedWarnings.error"
          :key="'error-' + idx"
          class="p-4 bg-red-50 border-l-4 border-red-500 rounded-r-lg"
        >
          <div class="flex items-start gap-2">
            <span class="text-red-500 font-bold">üî¥ ERROR</span>
          </div>
          <p class="mt-1 text-red-800">{{ warning.message }}</p>
        </div>

        <!-- Warnings -->
        <div
          v-for="(warning, idx) in groupedWarnings.warning"
          :key="'warning-' + idx"
          class="p-4 bg-amber-50 border-l-4 border-amber-500 rounded-r-lg"
        >
          <div class="flex items-start gap-2">
            <span class="text-amber-600 font-bold">üü° WARNING</span>
          </div>
          <p class="mt-1 text-amber-800">{{ warning.message }}</p>
        </div>

        <!-- Info -->
        <div
          v-for="(warning, idx) in groupedWarnings.info"
          :key="'info-' + idx"
          class="p-4 bg-blue-50 border-l-4 border-blue-500 rounded-r-lg"
        >
          <div class="flex items-start gap-2">
            <span class="text-blue-600 font-bold">üü† INFO</span>
          </div>
          <p class="mt-1 text-blue-700">{{ warning.message }}</p>
          <p class="mt-2 text-sm text-blue-600">
            üí° Instagram ‚Üí Configuraci√≥n ‚Üí Tu actividad ‚Üí Descargar informaci√≥n
          </p>
        </div>
      </div>
    </div>
  `
};

// ResultsSection Component
const ResultsSection = {
  props: {
    results: { type: Array, default: () => [] },
    whitelistSet: { type: Set, default: () => new Set() }
  },
  emits: ['add-to-whitelist'],
  setup(props, { emit }) {
    const searchQuery = ref('');
    const sortOrder = ref('newest');

    const filteredResults = computed(() => {
      let filtered = [...props.results];

      if (searchQuery.value.trim()) {
        const query = searchQuery.value.toLowerCase();
        filtered = filtered.filter(u => u.username.toLowerCase().includes(query));
      }

      if (sortOrder.value === 'newest') {
        filtered.sort((a, b) => b.timestamp - a.timestamp);
      } else if (sortOrder.value === 'oldest') {
        filtered.sort((a, b) => a.timestamp - b.timestamp);
      } else if (sortOrder.value === 'alpha') {
        filtered.sort((a, b) => a.username.localeCompare(b.username));
      }

      return filtered;
    });

    const formatDate = (timestamp) => {
      return new Date(timestamp * 1000).toLocaleDateString('es', {
        day: 'numeric',
        month: 'short',
        year: 'numeric'
      });
    };

    const openProfile = (href) => {
      window.open(href, '_blank');
    };

    const addToWhitelist = (user) => {
      emit('add-to-whitelist', user.username);
    };

    return {
      searchQuery,
      sortOrder,
      filteredResults,
      formatDate,
      openProfile,
      addToWhitelist
    };
  },
  template: `
    <section v-if="results.length > 0">
      <!-- Search and Sort Bar -->
      <div class="flex flex-col sm:flex-row gap-3 mb-4">
        <div class="flex-1 relative">
          <span class="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400">üîç</span>
          <input
            v-model="searchQuery"
            type="text"
            placeholder="Buscar username..."
            class="w-full pl-10 pr-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none"
          />
        </div>
        <select
          v-model="sortOrder"
          class="px-4 py-3 border border-gray-300 rounded-lg bg-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none"
        >
          <option value="newest">M√°s recientes</option>
          <option value="oldest">M√°s antiguos</option>
          <option value="alpha">A-Z</option>
        </select>
      </div>

      <!-- Results Count -->
      <p class="text-gray-600 mb-4">
        üìã <strong>{{ filteredResults.length }}</strong> de {{ results.length }} no te siguen
      </p>

      <!-- Mobile Cards (visible on small screens) -->
      <div class="md:hidden space-y-3">
        <div
          v-for="user in filteredResults"
          :key="user.href"
          class="bg-white border border-gray-200 rounded-xl p-4 shadow-sm"
        >
          <div class="flex items-center justify-between mb-2">
            <span class="font-semibold text-gray-800">@{{ user.username }}</span>
          </div>
          <p class="text-sm text-gray-500 mb-3">Seguido: {{ formatDate(user.timestamp) }}</p>
          <div class="flex gap-2">
            <button
              @click="openProfile(user.href)"
              class="flex-1 min-h-[44px] px-4 py-2 bg-blue-500 text-white rounded-lg font-medium hover:bg-blue-600 active:bg-blue-700 transition-colors"
            >
              Ir a perfil
            </button>
            <button
              @click="addToWhitelist(user)"
              class="min-h-[44px] px-4 py-2 border border-gray-300 rounded-lg font-medium hover:bg-gray-50 active:bg-gray-100 transition-colors"
              title="A√±adir a whitelist"
            >
              + WL
            </button>
          </div>
        </div>
      </div>

      <!-- Desktop Table (visible on medium+ screens) -->
      <div class="hidden md:block bg-white border border-gray-200 rounded-xl overflow-hidden shadow-sm">
        <table class="w-full">
          <thead class="bg-gray-50 border-b border-gray-200">
            <tr>
              <th class="px-6 py-4 text-left text-sm font-semibold text-gray-700">Username</th>
              <th class="px-6 py-4 text-left text-sm font-semibold text-gray-700">Fecha seguido</th>
              <th class="px-6 py-4 text-right text-sm font-semibold text-gray-700">Acciones</th>
            </tr>
          </thead>
          <tbody class="divide-y divide-gray-100">
            <tr
              v-for="user in filteredResults"
              :key="user.href"
              class="hover:bg-gray-50 transition-colors"
            >
              <td class="px-6 py-4">
                <span class="font-medium text-gray-800">@{{ user.username }}</span>
              </td>
              <td class="px-6 py-4 text-gray-600">{{ formatDate(user.timestamp) }}</td>
              <td class="px-6 py-4 text-right">
                <div class="flex justify-end gap-2">
                  <button
                    @click="openProfile(user.href)"
                    class="px-4 py-2 bg-blue-500 text-white rounded-lg text-sm font-medium hover:bg-blue-600 transition-colors"
                  >
                    Ir a perfil
                  </button>
                  <button
                    @click="addToWhitelist(user)"
                    class="px-4 py-2 border border-gray-300 rounded-lg text-sm font-medium hover:bg-gray-50 transition-colors"
                  >
                    + Whitelist
                  </button>
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>

      <!-- Empty state when filtered -->
      <div v-if="filteredResults.length === 0 && results.length > 0" class="text-center py-8 text-gray-500">
        <p class="text-4xl mb-2">üîç</p>
        <p>No se encontraron resultados para "{{ searchQuery }}"</p>
      </div>
    </section>

    <!-- Empty state when no results at all -->
    <div v-else-if="results.length === 0" class="text-center py-12 text-gray-500">
      <p class="text-4xl mb-2">‚ú®</p>
      <p class="text-lg font-medium">¬°Todos te siguen de vuelta!</p>
      <p class="text-sm mt-1">O a√∫n no has cargado los archivos</p>
    </div>
  `
};

createApp({
  components: { DropZone, WarningsPanel, ResultsSection },
  setup() {
    const followers = ref(null);
    const following = ref(null);
    const whitelist = ref(null);
    const errors = reactive({
      followers: null,
      following: null,
      whitelist: null
    });

    const followersNormalized = ref(null);
    const followingNormalized = ref(null);
    const whitelistSet = ref(new Set());
    const allWarnings = ref([]);
    const results = ref([]);

    const storedWhitelist = localStorage.getItem('ig-analyzer-whitelist');
    if (storedWhitelist) {
      try {
        const parsed = JSON.parse(storedWhitelist);
        whitelistSet.value = new Set(parsed.usernames?.map(u => u.toLowerCase()) || []);
      } catch (e) {
        console.warn('Could not parse stored whitelist');
      }
    }

    const saveWhitelist = () => {
      const data = {
        version: 1,
        updatedAt: new Date().toISOString(),
        usernames: Array.from(whitelistSet.value)
      };
      localStorage.setItem('ig-analyzer-whitelist', JSON.stringify(data));
    };

    const processData = () => {
      if (!followers.value || !following.value) return;

      const warnings = [];

      const { normalized: normFollowers, warnings: warnFollowers } = normalizeData(followers.value, 'followers');
      followersNormalized.value = normFollowers;
      warnings.push(...warnFollowers);

      const { normalized: normFollowing, warnings: warnFollowing } = normalizeData(following.value, 'following');
      followingNormalized.value = normFollowing;
      warnings.push(...warnFollowing);

      const hasBlockingError = warnings.some(w => w.type === 'error');
      if (hasBlockingError) {
        allWarnings.value = warnings;
        results.value = [];
        return;
      }

      if (whitelist.value) {
        const imported = parseWhitelist(whitelist.value);
        for (const username of imported) {
          whitelistSet.value.add(username);
        }
        saveWhitelist();
      }

      const { notFollowingBack, warnings: compareWarnings } = compareUsers(
        normFollowers,
        normFollowing,
        whitelistSet.value
      );

      warnings.push(...compareWarnings);
      allWarnings.value = warnings;
      results.value = notFollowingBack;
    };

    const handleFollowersLoaded = ({ data, error }) => {
      if (error) {
        errors.followers = error;
        followers.value = null;
      } else {
        errors.followers = null;
        followers.value = data;
        processData();
      }
    };

    const handleFollowingLoaded = ({ data, error }) => {
      if (error) {
        errors.following = error;
        following.value = null;
      } else {
        errors.following = null;
        following.value = data;
        processData();
      }
    };

    const handleWhitelistLoaded = ({ data, error }) => {
      if (error) {
        errors.whitelist = error;
        whitelist.value = null;
      } else {
        errors.whitelist = null;
        whitelist.value = data;
        processData();
      }
    };

    const followersCount = computed(() => {
      if (!followers.value) return null;
      return Array.isArray(followers.value) ? followers.value.length : 0;
    });

    const followingCount = computed(() => {
      if (!following.value) return null;
      const data = following.value.relationships_following || following.value;
      return Array.isArray(data) ? data.length : 0;
    });

    const addToWhitelist = (username) => {
      whitelistSet.value.add(username.toLowerCase());
      saveWhitelist();
      processData();
    };

    return {
      followers,
      following,
      whitelist,
      errors,
      followersCount,
      followingCount,
      handleFollowersLoaded,
      handleFollowingLoaded,
      handleWhitelistLoaded,
      allWarnings,
      results,
      whitelistSet,
      processData,
      saveWhitelist,
      addToWhitelist
    };
  },
  template: `
    <div class="max-w-4xl mx-auto px-4 py-8">
      <header class="text-center mb-8">
        <h1 class="text-2xl md:text-3xl font-bold text-gray-800">üìä Instagram Follower Analyzer</h1>
        <p class="text-gray-600 mt-2">Descubre qui√©n no te sigue de vuelta</p>
      </header>

      <section class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
        <DropZone
          label="Followers"
          :loaded="!!followers"
          :count="followersCount"
          :error="errors.followers"
          @file-loaded="handleFollowersLoaded"
        />
        <DropZone
          label="Following"
          :loaded="!!following"
          :count="followingCount"
          :error="errors.following"
          @file-loaded="handleFollowingLoaded"
        />
        <DropZone
          label="Whitelist (opcional)"
          :loaded="!!whitelist"
          :count="Array.isArray(whitelist) ? whitelist.length : whitelist?.usernames?.length"
          :error="errors.whitelist"
          @file-loaded="handleWhitelistLoaded"
        />
      </section>

      <WarningsPanel :warnings="allWarnings" />

      <ResultsSection
        :results="results"
        :whitelist-set="whitelistSet"
        @add-to-whitelist="addToWhitelist"
      />
    </div>
  `
}).mount('#app');
</script>
</body>
</html>
